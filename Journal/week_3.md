# Week 3 (22 May to 29 May)

- [Summary](#summary)
- [Getting familar with nextflow](#getting-familar-with-nextflow)
- [Comparison between nextflow and bionode-watermill](#comparison-between-nextflow-and-bionode-watermill)


## Summary

During this week I've mostly worked on [nextflow](https://www.nextflow.io/) which is Domain Specific language and helps to
make the adaptation of pipelines written in the most common scripting languages. So, I started learning nextflow and able to
do various [examples](https://github.com/evoxtorm/watermill_examples/tree/master/nextflow%20tutorial). Then I compared nextflow
with bionode-watermill because both these helps to make bioinformatic pipelines but some processes are well handled by 
nextflow.



## Getting familar with nextflow

I started working on nextflow with the help of [docs](https://www.nextflow.io/docs/latest/index.html) and [nf example repo](https://github.com/nextflow-io/examples).
 Afterwards I started comparing nextflow with bionode-watermill and both of them help to make the pipeline but some 
 processes is well easily handled in nextflow like use of channels. I also made two mappers example in nextflow but face lot's
 of difficulity while doing it like sometime docker issues and sometimes tool issue which is a real pain for a new person.
 


## Comparison between nextflow and bionode-watermill

Nextflow and bionode-watermill has lot's of similarity like code redusability and automated input/output handling.
While doing some of the examples in nextflow the use of channels makes the process easy.

* In nextflow we can use input of one process with channels so that it can be reused again like this
   
   ` ( samples1, samples2, ... , samplesN ) = samples.into(N)` 

* In nextflow `input` block defines which `channels` the **process** is expecting to receive inputs data from and output 
  allows to define the `channels` used by the **process** to send out the results produced. With the help of `channels` 
  `output` can be reused in different **processes** and this s one of the major advantage to use [nextflow](https://www.nextflow.io/).
  
 * Bionode-watermill and nextflow can use various scripting language just you have to do
 
     ``` python
     !#/usr/bin/env python
     ```
 
* In watermill `Input/Output`can be a **string glob pattern**, or a plain object of them. The glob will be **resolved to an
absolute path** when it is passed to the `operationCreator`. Bionode-watermill manages input and output files and folders
run by a `task`. All inputs and outputs are saved within data folder (generated by running bionode-watermill) in the
current working directory. It is difficult to design which **outputs** go to what **inputs** in watermill because it just 
goes up `DAG(Directed Acyclic Graph)` until found an output matching desired input pattern, so it can be ambiguous.

![alt text](https://github.com/bionode/gsoc18/blob/master/Images/Screenshot-from-2018-05-26-13-25-52.png "DAG")

  ```cypher 
     CREATE
   (a:Task { label: 'A'}), (b:Task { label: 'B'}), (c:Task { label: 'C'}), (d:Task { label: 'D'}),
   (a1:File { label: 'a1'}), (a2:File { label: 'a2'}), (a3:File { label: 'a3'}), 
   (b1:File { label: 'b1'}), (b2:File { label: 'b2'}),

   (a)-[:Output]->(a1),
   (a)-[:Output]->(a2),
   (a)-[:Output]->(a3),

   (a1)-[:Input]->(b),
   (a2)-[:Input]->(c),
   (a3)-[:Input]->(c),

   (b)-[:Output]->(b1),
   (b)-[:Output]->(b2),

   (b1)-[:Input]->(d) 
 ```

